package ohc
package annotation

import language.experimental.macros
import scala.annotation.{ StaticAnnotation, compileTimeOnly}
import scala.reflect.macros.whitebox.Context

@compileTimeOnly("structs should be processed by the compiler")
class struct(debug: Boolean = false) extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro StructMacros.structMacro
}

class StructMacros(val c: Context) {
  import c.universe._


  def structMacro(annottees: Tree*): Tree = {
    val debug = c.prefix.tree match {
      case q"new struct(debug = ${Literal(Constant(debug: Boolean))})" => debug
      case _ => false
    }
    //the passed code must typecheck just fine, hence we first apply the typechecker
    val typedAnnottees = annottees match {
      case Seq(head, tail @ _*) => c.typecheck(head) +: tail //only typecheck the head, never the tail because it could trigger a recursive call of this macro
    }
    //    println(typedAnnottees)
    val res = typedAnnottees match {
      case Seq(clazz) if clazz.symbol.isClass =>
        val (c, o) = implementClassAndCompanion(clazz, q"object ${clazz.symbol.name.toTermName}")
        q"{$c; $o}"

      case Seq(clazz, companion) if clazz.symbol.isClass =>
        val (c, o) = implementClassAndCompanion(clazz, companion)
        q"{$c; $o}"

      case other => c.abort(c.enclosingPosition, "Annotated element is not a class: " + other)
    }
    if(debug) c.info(c.enclosingPosition, showCode(res), true)
    res
  }
  private def implementClassAndCompanion(clazz: Tree, companion: Tree): (Tree, Tree) = {
    // check that the class is not a case class
    if (clazz.symbol.asClass.isCaseClass) c.abort(clazz.pos, "Cannot annotate a case class, because the generated by standard scala is not compatible with off-heap structures")

    val q"$mods class $tpname[..$tparams] $ctorMods(..$params) extends { ..$earlydefns } with ..$parents { $self => ..$stats }" = clazz

    //check that one of the tparams is an AllocatorDefinition
    if (tparams.size != 1) c.abort(c.enclosingPosition, "A structure must only define one type parameter such as T <: Allocator")
    val allocatorGenericParam = tparams.head match {
      case t@TypeDef(_, tparamName, _, tt@TypeTree()) if {
          val TypeBoundsTree(_, hi@TypeTree()) = tt.original
          tt.original.tpe.baseType(symbolOf[Allocator[_]]) != NoType
        } => tparamName
      case other => c.abort(other.pos, "You need to have one type parameter that extends Allocator")
    }

    //check that the body doesn't contain any val or var, this are not allowed
    stats foreach {
      case t@ValDef(mods, _, _, _) => c.error(t.pos, "Invalid variable declaration. Structures must declare their variables in the constructor")
      case _ =>
    }

    // fold the params obtaining getters and setters
    val (totalSize: Int, gettersAndSetters: Seq[Tree]) = params.foldLeft((0, Seq[Tree]())) {
      case ((offset, accum), t@ValDef(mods, name, tpe, rhs)) =>
        if (TypeSize.isDefinedAt(tpe.tpe)) {
          val typeSize = TypeSize(tpe.tpe)
          val position = offset
          val accessors = q"def $name(implicit a: $allocatorGenericParam) = a.memory.${TermName("get" + tpe)}(pointer + $position)" +:
          (if (mods.hasFlag(Flag.MUTABLE))
            Seq(q"def ${TermName(name + "_=")}(v: $tpe)(implicit a: $allocatorGenericParam) = a.memory.${TermName("set" + tpe)}(pointer + $position, v)")
           else Seq.empty)
          (offset + typeSize, accum ++ accessors)
        } else {
          c.error(t.pos, "Unsized type " + tpe)
          (offset, accum)
        }
    }

    val resultClass = {
      val totalParents = Seq(tq"AnyVal", tq"_root_.ohc.Struct[$allocatorGenericParam]") ++ parents.filterNot(t => t.tpe =:= definitions.ObjectTpe || t.tpe =:= definitions.AnyRefTpe)
      q"""
        $mods class $tpname[$allocatorGenericParam <: _root_.ohc.Allocator[$allocatorGenericParam]](val pointer: Long) extends ..$totalParents {
          ..${gettersAndSetters}

          ..$stats
        }
        """
    }

    val resultCompanion = {

      val q"$mods object $tpname extends { ..$earlydefns } with ..$parents { $self => ..$stats }" = companion

      val fieldAssignations = params map (p => q"""res.${TermName(p.name.decodedName.toString + "_=")}(${p.name})""")
      val applyBody = q"""
        val res = alloc.allocate[${tpname.toTypeName}]
        ..$fieldAssignations
        res"""

      val applyMethod = q"""def apply[A <: _root_.ohc.Allocator[A]](..$params)(implicit alloc: A): ${tpname.toTypeName}[A] = { ..$applyBody }"""
      val paramNames = params.map(p => q"o.${p.name}")
      val unapplyMethod = q"""def unapply[A <: _root_.ohc.Allocator[A]](o: ${tpname.toTypeName}[A])(implicit a: A) = Some((..$paramNames))"""


      q"""
      $mods object $tpname extends {..$earlydefns} with ..$parents {
        ..$stats

        implicit val ${TermName(tpname + "Struct")} = new StructDef[${tpname.toTypeName}] {
          def apply[A <: _root_.ohc.Allocator[A]](pointer: Long): ${tpname.toTypeName}[A] = new ${tpname.toTypeName}[A](pointer)
          def size: Long = $totalSize
        }

        $applyMethod
        $unapplyMethod
      }
      """
    }

    (resultClass, resultCompanion)
  }

  private val TypeSize: PartialFunction[Type, Int] = {
    case definitions.BooleanTpe => 1
    case definitions.CharTpe => 2
    case definitions.ByteTpe => 1
    case definitions.ShortTpe => 2
    case definitions.IntTpe => 4
    case definitions.LongTpe => 8
    case definitions.FloatTpe => 4
    case definitions.DoubleTpe => 8
  }
}
